// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Screen.jack

/**
 * A library of functions for displaying graphics on the screen.
 * The Hack physical screen consists of 512 rows (indexed 0..511, top to bottom)
 * of 256 pixels each (indexed 0..255, left to right). The top left pixel on 
 * the screen is indexed (0,0).
 */
class Screen {

    // each entry is a 16-pixel line, with 8192 = (24576 - 16384) entries
    static Array screen, twoToThe; 
    static boolean color, WHITE_COLOR, BLACK_COLOR;
    static int WHITE, BLACK, SCREEN_RANGE;

    /** Initializes the Screen. */
    function void init() {
        let screen = 16384;
        let SCREEN_RANGE = 8192;
        let WHITE_COLOR = false; // setting bit to 0 equals setting bit to be white
        let BLACK_COLOR = true; // setting bit to 1 equals setting bit to be black
        let WHITE = 0;
        let BLACK = -1;
        let color = BLACK;
        let twoToThe = Math.twoToTheMap();

        return;
    }

    /** Erases the entire screen. */
    function void clearScreen() {
        var int i;

        let i = 0;

        while (i < SCREEN_RANGE) {
            let screen[i] = WHITE;

            let i = i + 1;
        }

        return;
    }

    /** Sets the current color, to be used for all subsequent drawXXX commands.
     *  Black is represented by true, white by false. */
    function void setColor(boolean b) {
        let color = b;

        return;
    }

    /** 
     *  Draws the (x,y) pixel, using the current color. 
     *  The screen resolution is 512 (width) times 256 (height) pixels.
     *  0 <= x <= 511
     *  0 <= y <= 255
     */
    function void drawPixel(int x, int y) {
        var int addr, prevMap, whichBit, singleBitMap;

        // compute the word corresponding to this pixel
        // y represents the row number, and each row has 512 pixels or 32 words (32 * 16 = 512).
        // x represetns the pixel index on a same line; x / 16 is the word index on a line to which
        // this pixel belongs to.
        let addr = (y * 32) + (x / 16);

        // fetch current value/bitmap
        let prevMap = screen[addr];

        // compute the bit within this word corresponding to this pixel
        // and use it to get the corresponding map (default color is black)
        // let whichBit = x - (16 * (x / 16)); // mod
        let whichBit = x & 15; // bits more significant than 15 (2**4 - 1) are divisible by 16
        let singleBitMap = twoToThe[whichBit];

        // set value according to color
        if (color = BLACK_COLOR) {
            let screen[addr] = prevMap | singleBitMap;
        } else { // while the current color is WHITE
            // First, fliping the bits then AND the prevMap, we preserve all information in the prevMap
            // Second, the target bit is to be set as 0 or the color of white
            let screen[addr] = prevMap & ~singleBitMap;
        }

        return;
    }

    /** Draws a line from pixel (x1,y1) to pixel (x2,y2), using the current color. */
    function void drawLine(int x1, int y1, int x2, int y2) {
        var int dx, dy, ax, ay; // diff of x, diff of y, actual curr x, actual curr y
        var int tempx, tempy;

        // make x2 always >= x1 to simply scenarios
        if (x1 > x2) {
            let tempx = x1;
            let tempy = y1;

            let x1 = x2;
            let y1 = y2;

            let x2 = tempx;
            let y2 = tempy;
        } else { // x1 <= x2
            if (y1 > y2) {
                let tempx = x1;
                let tempy = y1;

                let x1 = x2;
                let y1 = y2;

                let x2 = tempx;
                let y2 = tempy;
            }
        }

        let dx = x2 - x1;
        let dy = y2 - y1;

        // horizontal or vertical?
        if (dx = 0) {
            // if (dy = 0) { // two same points
            //     do Screen.drawPixel(x1, y1);
            // } else { // y1 != y2 vertical line
                if (y1 > y2) {
                    do Screen.drawVertical(y2, y1, x1);
                } else {
                    do Screen.drawVertical(y1, y2, x1);
                }
            // }
        } else { // x1 != x2
            if (dy = 0) {
                // x1 != x2 but y1 == y2 -> horizontal line
                if (x2 > x1) {
                    do Screen.drawHorizontal(x1, x2, y1);
                } else { // x2 <= x1
                    do Screen.drawHorizontal(x2, x1, y1);
                }
            }
        }

        // if x1 != x2 && y1 != y2
        
        return;
    }


    /**
     * Assume x2 > x1
     */
    function void drawHorizontal(int x1, int x2, int y) {
        var int startWordAddress, endWordAddress;
        var int i, j, xmod, edgeWord;

        if (x1 = x2) {
            do Screen.drawPixel(x1, y);
        }

        let startWordAddress = y * 32 + (x1 / 16);
        let endWordAddress = y * 32 + (x2 / 16);
        let j = startWordAddress + 1;

        // first word
        let edgeWord = 0;
        let xmod = x1 & 15;
        // made all bits more significant than x1 in this word drawn
        let i = 15;
        while (~(i < xmod)) {
            let edgeWord = edgeWord | twoToThe[i];
            let i = i - 1;
        }

        if (color = BLACK_COLOR) {
            let screen[startWordAddress] = screen[startWordAddress] | edgeWord;
        } else {
            let screen[startWordAddress] = screen[startWordAddress] & ~edgeWord;
        }

        // all words in between
        while (j < endWordAddress) {
            let screen[j] = color; // set all to be the current color
            // increment
            let j = j + 1;
        }

        // last word
        let edgeWord = 0; // reuse local variable
        let xmod = x2 & 15;

        // made all bits less significant than x1 in this word drawn
        let i = 0;
        while (~(i > xmod)) {
            let edgeWord = edgeWord | twoToThe[i];
            let i = i + 1;
        }
        
        if (color = BLACK_COLOR) {
            let screen[endWordAddress] = screen[endWordAddress] | edgeWord;
        } else {
            let screen[endWordAddress] = screen[endWordAddress] & ~edgeWord;
        }

        return ;
    }
    
    
    /**
     * Set the same bit in words vertically aligned, or with address difference of 32.
     *  Assume y2 > y1
     */
    function void drawVertical(int y1, int y2, int x) {
        var int startWordAddress, endWordAddress;
        var int i, xmod, bitmapMask;

        if (y1 = y2) {
            do Screen.drawPixel(x, y1);
        }
        
        let startWordAddress = y1 * 32 + (x / 16);
        let endWordAddress = y2 * 32 + (x / 16);
        let xmod = x & 15;
        let bitmapMask = twoToThe[xmod];
        let i = startWordAddress;


        while (~(i > endWordAddress)) {
            if (color = BLACK_COLOR) {
                let screen[i] = screen[i] | bitmapMask;
            } else {
                let screen[i] = screen[i] & ~bitmapMask;
            }

            let i = i + 32;
        }
        
        return ;
    }

    /** 
     * Draws a filled rectangle whose top left corner is (x1, y1)
     * and bottom right corner is (x2,y2), using the current color. 
     * 
     * Draw two vertical lines and two horizontal lines. 
     * 
     */
    function void drawRectangle(int x1, int y1, int x2, int y2) {
        // horizontal #1
        do Screen.drawHorizontal(x1, x2, y1);
        // horizontal #2
        do Screen.drawHorizontal(x1, x2, y2);
        // vertical #1
        do Screen.drawVertical(y1, y2, x1);
        // vertical #2
        do Screen.drawVertical(y1, y2, x2);
        
        return;
    }

    /** Draws a filled circle of radius r<=181 around (x,y), using the current color. */
    function void drawCircle(int x, int y, int r) {
        return;
    }
}
